---
title: "DGEobj.utils: An Example Workflow"
author: "John R. Thompson"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:   
    fig_caption: yes
    number_sections: yes
    toc: yes
    toc_depth: 5
vignette: >
  %\VignetteIndexEntry{DGEobj.utils: An Example Workflow}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8} 
---

```{r global_options, include = FALSE}
knitr::opts_chunk$set(echo    = TRUE, 
                      include = TRUE, 
                      warning = FALSE, 
                      message = FALSE, 
                      eval    = TRUE)

suppressPackageStartupMessages({
    library(biomaRt)
    library(dplyr)
    library(glue)
    # library(edgeR)
    # library(kableExtra)
    library(DGEobj)
    library(DGEobj.utils)
    library(stringr)
    library(knitr)
    library(conflicted)
    library(ggplot2)
    library(sva)
    
# library(tidyverse)
# library(JRTutil)  #need to remove this dependency (BMS internal package)
# library(parallel)
# library(doParallel)
})

conflict_prefer("select",    "dplyr",   quiet = TRUE)
conflict_prefer("filter",    "dplyr",   quiet = TRUE)
conflict_prefer("left_join", "dplyr",   quiet = TRUE)
conflict_prefer("rename",    "dplyr",   quiet = TRUE)
# conflict_prefer("collapse",  "glue",    quiet = TRUE) 
```


# Introduction and Setup

## Demonstration Dataset: Rat Liver Slice Compound Treatments

The following dataset was selected to demonstrate building and working with the DGEobj data structure and associated utilities

>  Huang X, Cai H, Ammar R, Zhang Y et al. Molecular characterization of a
>  precision-cut rat liver slice model for the evaluation of antifibrotic
>  compounds. Am J Physiol Gastrointest Liver Physiol 2019 Jan 1;316(1):G15-G24. PMID: 30406699  

Briefly, livers were removed from rats 4 weeks after bile duct ligation or sham operation. Rat liver slices were incubated in vitro with potential anti-fibrotic compounds. At the end of the incubation whole transcriptome RNA-Seq analysis was performed.

Files containing counts, sample annotations, and QC data associated with this project can be downloaded from the [NCBI GEO resource](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE120804).

The GEO data includes Ensembl gene IDs. Additional gene information such as chromosome positions, type of transcript, etc, are downloaded from Ensembl using the biomaRt package.

## Starting DGEobj creation

The starting point for the discussions in this vignette is a DGEobj that is ready for analysis.  The demonstration dataset detailed above is used to create the DGEobj R object step-by-step in sections 1-4 of the DGEobj package vignette:  [DGEobj_Overview](https://cran.r-project.org/web/packages/DGEobj/vignettes/DGEobj_Overview.html).  This vignette can be accessed from inside an R session using `vignette("DGEobj_Overview", package = "DGEobj")`.  The detailed instructions are not be repeated in this vignette, but the starting R object named "dgeObj" is created with exactly the same steps/data as detailed in sections 1-4.

```{r baseDGEcreation, include = F}

annotation_text <- '
# general project metadata
level=gene
source=Omicsoft
ID=BDL_Rat_LiverSlice_03Dec2017
Title=Rat Liver Slices from Bile Duct Ligation animals
Organism=Rat
GeneModel=Ensembl.R89
PlatformType=RNA-Seq
Description=Rat livers slices from sham or BDL +/- efficacious treatments incubated in vitro
Keywords=Liver slices; Bile Duct Ligation
Disease=Liver Fibrosis
Tissue=Liver
GEO=GSE120804
# additional technical data processing attributes
Technology=Illumina-HiSeq
LibraryPrep=TruSeq Stranded Total RNA
AlignmentReference=Rat.B6.0
ReadType=PE
Pipeline=RNA-Seq_BMS_v2.4.pscript
AlignmentAlgorithm=OSA
ScriptID=RNA-Seq_BMS_v2.4.pscript
# institutional attributes
BusinessUnit=Discovery
FunctionalArea=Fibrosis
Vendor=BMS
TBio_Owner=Ron Ammar
TA_Owner=John Huang
'

annotationFile <- tempfile(fileext = ".txt")
writeLines(annotation_text, con = annotationFile)

# Get the raw counts, sample annotation ("design"), and QC data from GEO
# Source: https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE120804
getLocation <- "http://ftp.ncbi.nlm.nih.gov/geo/series/GSE120nnn/GSE120804/suppl"
countsFile  <- "GSE120804_counts.txt.gz"
designFile  <- "GSE120804_geo_sample_annotation_edit.csv.gz"
qcFile      <- "GSE120804_qc_metrics.txt.gz"

temp <- tempfile()
if (download.file(glue("{getLocation}/{countsFile}"), destfile = temp, mode = 'wb') > 0) {
    stop("Counts Download Failed")
}
counts <- read.delim(temp, stringsAsFactors = FALSE, row.names = 1)

temp <- tempfile()
if (download.file(glue("{getLocation}/{designFile}"), destfile = temp, mode = 'wb')) {
    stop("Design Download Failed")
}
design <- read.csv(temp, stringsAsFactors = FALSE)

temp <- tempfile()
if (download.file(glue("{getLocation}/{qcFile}"), destfile = temp, mode = 'wb')) {
    stop("Alignment QC Download Failed")
}
alignmentQC <- read.delim(temp, stringsAsFactors = FALSE)

rownames(design) <- str_sub(design$raw.file, start = 1, end = 21)

#correct the desired case/spelling of one column
design <- design %>%
    rename(ReplicateGroup = Replicate.group)

# Create a DiseaseStatus column by parsing ReplicateGroup
design$DiseaseStatus <- rep("Sham", nrow(design))
idx <- str_detect(design$ReplicateGroup, "BDL")
design$DiseaseStatus[idx] <- "BDL"

# Create an animal# column.  The animal number is encoded in the sample.name column
design$AnimalNum <- str_match(design$Sample.name, "r[0-9]{1,3}")

# Now get the gene annotation from Ensembl/biomaRt
ens.ds      <- "rnorvegicus_gene_ensembl"
ens.mart    <- useMart(biomart = "ensembl", dataset = ens.ds)
ens.columns <- c("ensembl_gene_id", "rgd_symbol", "chromosome_name", "start_position",
                 "end_position", "strand", "gene_biotype", "description")
ens.data    <- getBM(attributes = ens.columns, 
                     values     = rownames(counts), 
                     mart       = ens.mart, 
                     useCache   = F) %>%
               distinct(ensembl_gene_id, .keep_all = T)

# Filter the list to the genes used in the test dataset and format gene info for GenomicRanges
gene.data <- left_join(data.frame(ensembl_gene_id = rownames(counts), stringsAsFactors = F),
                       ens.data,
                       by = "ensembl_gene_id") %>%
    dplyr::rename(start = start_position, end = end_position) %>%
    mutate(strand = case_when(strand == -1 ~ "-",
                              strand == 1  ~ "+",
                              TRUE         ~ "*"))
rownames(gene.data) <- gene.data$ensembl_gene_id

# Get transcript level data and keep max for each gene, or alternatively, use the cds length
ens.ds          <- "rnorvegicus_gene_ensembl"
ens.mart        <- useMart(biomart = "ensembl", dataset = ens.ds)
ens.columns     <- c("ensembl_gene_id", "ensembl_transcript_id", "transcript_length")
transcript.data <- getBM(attributes = ens.columns, 
                         values     = rownames(counts), 
                         mart       = ens.mart, 
                         useCache   = F) %>%
                   arrange(desc(transcript_length)) %>%
                   distinct(ensembl_gene_id, .keep_all = T)

#Add a transcript_length column to gene.data
gene.data <- left_join(gene.data, 
                       select(transcript.data, ensembl_gene_id, ExonLength = transcript_length))
rownames(gene.data) <- gene.data$ensembl_gene_id
gene.data$ensembl_gene_id <- NULL

# enforce same order as counts
gene.data <- gene.data[rownames(counts),]

dgeObj <- DGEobj::initDGEobj(primaryAssayData  = counts,
                             rowData = gene.data,
                             colData = design,
                             level = "gene",
                             customAttr = list(Genome    = "Rat.B6.0",
                                               GeneModel = "Ensembl.R89"))

dgeObj <- annotateDGEobj(dgeObj, annotationFile)
```

Columns available in this object for building contrasts:

```{r build_cols}
designCol <- "ReplicateGroup"

levels <- str_c(designCol, (unique(dgeObj$design[[designCol]])))
kable(levels)
```

Since we want to use formulas we have a few additional steps that may be necessary depending on the data:

```{r projconfig}
# Next step is only necessary IF you have a numeric column that you
# want to treat as a factor in formulas.
dgeObj$design$ReplicateGroup <- as.factor(dgeObj$design$ReplicateGroup)

## The next step is only necessary if you want to use a ~ 1 formula, then 
## the desired baseline must be made the first factor and thus the default baseline..
dgeObj$design$ReplicateGroup <- relevel(dgeObj$design$ReplicateGroup, "Sham")

# Print the contents of the dgeObj
kable(inventory(dgeObj))
```

## Limma/Voom Workflow Reference

At this point our starting object is fully setup for the analysis we wish to perform so we will proceed to run the Limma/Voom Differential Gene Expression analysis as described in:

>  TBD
>  TBD
>  TBD  


# Pre-processing

## Low Intensity Filtering

Typically, genes with near zero counts are removed before further analysis. They
contain no useful information, increase the multiple test burden, asnd could
(under some conditions) compromise the normalization and violate assumptions
implicit in linear modeling.

Two methods for low intensity filtering are supplied; min counts, and
FPK.  The lowIntFilter function will use any combination of these methods.  The
sampleFraction argument defines the proportion of samples that must meet all
specified criteria to keep a gene.  

We typically recommend using counts >= 10 and FPK >=5.  But the filter should be
set as close as possible to criteria the original analyst used.  A custom filter
can also be substituted.

Minmum counts >= 10 is commonly used to filter out low intensity genes.  But
mincounts is biased against short genes.  In contrast, FPK (fragments per
kilobase), described below, provides an intensity measure that is not length biased.  
  
Fragments Per Killobase (FPK) is another filtering criterion.  For an average
size ~2kb mRNA FPK = 5 is equivalent to counts = 10, however, FPK is not length
biased.   Another useful property of FPK is that FPK can be calculated for
intergenic DNA and thus provides an empirical background level of stochastic or
spurious transcription.  This estimate is surely conservative in that there is
very likely some real transcription going on in intergenic regions.  Typically,
the intergenic FPK level is below 5 so FPK >= 5 is an appropriate threshold.

The FPK + mincount filters can both be applied together to selecte detected
genes. The one must decide how to integrate this information across multiple
samples and experiment groups. You can get more sophisticated and do this on a
group-wise basis so you can include genes that were expressed in at least one of
your treatment groups. I leave that as an exercise for the reader and note that
groupwise filtering introduces a bias that affects your pvalue calibration.  To
avoid such bias, we simply require 50% of samples to pass the intensity
threshold and you can modify the percentage to adjust the stringency.

If you use FPK, a length adjusted measure, you must also supply the geneLength
argument. A Gene length vlue for each gene is thus required in the gene
annotation if FPK is to be used.  The RSEM algorithm for generating gene counts
also provide an effective length calculation for each gene that may be 
conveniently used for the FPK calculations.

In this example, only the counts were provided in the GEO source and thus the
genelength information required to use FPK is not available.  Therefore, a
simple count threshold will be used and 50% of samples are required to meet
these criteria for the gene to be included.


Dimensions before filtering: 
`r dim(dgeObj)`

```{r LowIntensityFilter}
### Gene Filter Criteria ###
countThreshold <- 10   # Must meet or exceed this value
sampleFraction <- 0.5  # Fraction of samples that must meet the established criteria

# low expression filter
dgeObj <- lowIntFilter(dgeObj, 
                       countThreshold = countThreshold,
                       sampleFraction = sampleFraction)

```

Dimensions after filtering: 
`r dim(dgeObj)`

## Filter for Protein Coding Genes  

Often an analysis is focused on protein-coding genes.  Here we use the Ensembl
gene_biotype column in the gene annotation to keep only protein-coding genes.

Here square bracket subsetting is used to sub-select protein-coding genes.  

```{r filterProteinCoding}
idx    <- dgeObj$geneData$gene_biotype == "protein_coding"
dgeObj <- dgeObj[idx,]
```

Dimensions after filtering for protein_coding:   
`r dim(dgeObj)`


# DGE Analysis  

## EdgeR Normalization  

This step simply applies edgeR::calcNormFactors to effect TMM normalization.
This results in a DGEList object being added to the DGEobj.  Note that the
counts matrix within the DGEList object is NOT normalized counts.  Rather a
separate item in the DGEList contains the norm factors and you should use the
edgeR cpm function to extract normalized counts from the DGEList.

```{r Normalize, fig.width=5, fig.height=3, eval = F}
dgeObj <- runEdgeRNorm(dgeObj, plotFile = TRUE)
```

## Define the Model Formula  

Provide a formula and construct the design matrix:

```{r ModelDefinition, eval = F}
### Formula must be composed of column names from the design table.
formula <- '~ 0 + ReplicateGroup'
# User-defined name for the designMatrix
designMatrixName <- "ReplicateGroupDesign"

# build the designMatrix
design <- getItem(dgeObj, "design")
designMatrix <- model.matrix(as.formula(formula), design)

# Make sure the column names in the design matrix are legal
colnames(designMatrix) <- make.names(colnames(designMatrix))

#capture the formula as an attribute of the design matrix
attr(designMatrix, "formula") <- formula

#add the designMatrix to the DGEobj
dgeObj <- addItem(dgeObj, 
                  item      = designMatrix, 
                  itemName  = designMatrixName, 
                  itemType  = "designMatrix",
                  parent    = "design", 
                  overwrite = TRUE)
```

## Check for Surrogate Variables (unaccounted-for variation)

SVA looks for hidden structure in the data using PCA-like methods.  It 
defines surrogate variables that can be added to your model to account 
for systematic trends that do not map to known experiment factors.  This
can improve power to detect changes due to factors of interest.

The ReplicateGroup design column captures both disease status and drug treatment
groups.  With this design, no SVs are detected.  

```{r checkForSV, eval = F}
log2cpm      <- convertCounts(dgeObj$counts, unit="cpm", log=TRUE, normalize="tmm")
designMatrix <- DGEobj::getItem(dgeObj, designMatrixName)

sva::num.sv(log2cpm, designMatrix, method = "leek")
```

To illustrate SVA use, a model is constructed using only disease status and
ignoring compound treatment.  The compound treatment effects should be
discoverable as a surrogate variable.  

Note that here the SVA output is captured in a fork of the main DGEobj.  

```{r runSVA, eval = F}
### Formula must be composed of column names from the design table.
formula <- '~ 0 + DiseaseStatus'
# User-defined name for the designMatrix
designMatrixName <- "DiseaseStatusDesign"

# build the designMatrix
design <- getItem(dgeObj, "design")
designMatrix <- model.matrix (as.formula(formula), design)

# Make sure the column names in the design matrix are legal
# convert spaces and other disallowed chars to underscores or dots
colnames(designMatrix) <- make.names(colnames(designMatrix))

#capture the formula as an attribute of the design matrix
attr(designMatrix, "formula") <- formula

#add the designMatrix to the DGEobj
dgeObj_SVA <- addItem(dgeObj, item=designMatrix, 
                  itemName=designMatrixName, 
                  itemType="designMatrix",
                  parent="design", 
                  overwrite=TRUE)

dgeObj_SVA <- runSVA(dgeObj_SVA, designMatrixName=designMatrixName)

```
Indeed SVA now identifies one surrogate varable.  

If n.sv is >0, the runSVA function adds the following changes to the DGEobj:  

1. Adds a column for each SV to the design table  
2. Stores the svobj from the SVA analysis  
3. Creates and stores a new design matrix with the sv columns and adds a "_sva" suffix to the designMatrix name   

The user can then use the new design matrix to incorporate the SVs into the analysis.   

```{r examineSVs, eval = F}

kable(inventory(dgeObj_SVA))

```


## Run Voom and fit the model (lmfit)  

The duplicateCorrelation method in voom optionally allows the user to account
for a random effect, such as repeated measurements on the same animal in this
case.  

To invoke duplicateCorrelation in the runVoom function, assign a blocking
variable to the dupCorBlock argument.  

```{r runVoom, eval=TRUE, echo=TRUE, warning=FALSE, message=FALSE, fig.height=3.5, eval = F}
### Use duplicateCorrelation when subjects have been sampled more than once even
### if under different conditions (e.g. treated, untreated) Pass a vector (usually
### a design column) representing the subject ID.
dupCorBlock <- dgeObj$design$AnimalNum 
designMatrixName <- "ReplicateGroupDesign"

if (is.null(dupCorBlock)) {
  dgeObj <- runVoom(dgeObj, designMatrixName)
} else {
  dgeObj <- runVoom(dgeObj, designMatrixName,
                           dupCorBlock = dupCorBlock)
}
# note: qualityWeights = TRUE,  runEBayes = TRUE and robust = TRUE are the defaults.

```




The Mean-variance trend nicely shows the heteroscedasticity typical of RNA-Seq
data (variance dependent on intensity).

If a downward hook on the left end of this distribution is observed, it means a
more stringent low intensity filter should be used.  


```{r snapshot2, eval=TRUE, echo=TRUE, warning=FALSE, message=FALSE, eval = F}
# Let's save a snapshot of the DGEobj at this point
saveRDS (dgeObj, file.path(outputPath, "dgeobj.RDS"))

# dgeObj <- readRDS(file.path(outputPath, "dgeobj.RDS"))

```



## Run contrasts  

Function runContrasts takes a named list of contrasts (see config chunk).  


```{r runContrasts, echo=TRUE, warning=FALSE, message=FALSE, eval = F}
# Name the design matrix to be used
designMatrixName <- "ReplicateGroupDesign"

# Print the available column names for constructing contrasts:
print(colnames(dgeObj$ReplicateGroupDesign))

##  Define the named contrasts from design matrix column names
contrastList  <- list(BDL_vs_Sham = "ReplicateGroupBDL - ReplicateGroupSham",
                      EXT1024_vs_BDL = "ReplicateGroupBDL_EXT.1024  - ReplicateGroupBDL",
                      Nint_vs_BDL = "ReplicateGroupBDL_Nint - ReplicateGroupBDL",
                        Sora_vs_BDL = "ReplicateGroupBDL_Sora - ReplicateGroupBDL"
)

dgeObj <- runContrasts(dgeObj, 
                       designMatrixName=designMatrixName, 
                       contrastList=contrastList, 
                       qValue=TRUE,
                       IHW = TRUE)
```


\scriptsize

`r knitr::kable(inventory(dgeObj))`  

\normalsize  

After executing runContrasts, the topTable dataframes are present in the DGEobj
and the DGE analysis is complete.  

## Alternative FDR scores  

topTable provides a BH FDR value (adj.P.Val).  Two optional 
FDR measures are supported that add additional columns to the topTable results.
Use the Qvalue and IHW arguments to invoke these additional FDR measures.   

Qvalue = TRUE adds "qvalue" and "qvalue.lfdr" columns to the topTable output.  

IHW = TRUE adds columns "ihw.adj_pvalue" and "ihw.weight".  

BrowseVignettes() for the qvalue and IHW packages for more details on these 
alternative FDR measures.  
