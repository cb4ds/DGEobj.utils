---
title: "DGEobj.utils: An Example Workflow"
author: "John R. Thompson"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:   
    fig_caption: yes
    number_sections: yes
    toc: yes
    toc_depth: 5
vignette: >
  %\VignetteIndexEntry{DGEobj.utils: An Example Workflow}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8} 
---

```{r global_options, include = FALSE}
knitr::opts_chunk$set(echo    = TRUE, 
                      include = TRUE, 
                      warning = FALSE, 
                      message = FALSE, 
                      eval    = TRUE, 
                      fig.height = 3.5,
                      fig.width  = 7)

suppressPackageStartupMessages({
    library(biomaRt)
    library(dplyr)
    library(glue)
    library(DGEobj)
    library(DGEobj.utils)
    library(stringr)
    library(knitr)
    library(conflicted)
    library(ggplot2)
    library(sva)
})

conflict_prefer("select",    "dplyr",   quiet = TRUE)
conflict_prefer("left_join", "dplyr",   quiet = TRUE)
conflict_prefer("rename",    "dplyr",   quiet = TRUE)
```


# Introduction and Setup

## Demonstration Dataset: Rat Liver Slice Compound Treatments

The following dataset was selected to demonstrate building and working with the DGEobj data structure and associated utilities

>  Huang X, Cai H, Ammar R, Zhang Y et al. Molecular characterization of a
>  precision-cut rat liver slice model for the evaluation of antifibrotic
>  compounds. Am J Physiol Gastrointest Liver Physiol 2019 Jan 1;316(1):G15-G24. PMID: 30406699  

Briefly, livers were removed from rats 4 weeks after bile duct ligation or sham operation. Rat liver slices were incubated in vitro with potential anti-fibrotic compounds. At the end of the incubation whole transcriptome RNA-Seq analysis was performed.

Files containing counts, sample annotations, and QC data associated with this project can be downloaded from the [NCBI GEO resource](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE120804).

The GEO data includes Ensembl gene IDs. Additional gene information such as chromosome positions, type of transcript, etc., are downloaded from Ensembl using the biomaRt package.

## Starting DGEobj creation

The starting point for the discussions in this vignette is a DGEobj that is ready for analysis.  The demonstration dataset detailed above is used to create the DGEobj R object step-by-step in sections 1-4 of the DGEobj package vignette:  [DGEobj_Overview](https://cran.r-project.org/web/packages/DGEobj/vignettes/DGEobj_Overview.html).  This vignette can be accessed from inside an R session using `vignette("DGEobj_Overview", package = "DGEobj")`.  The detailed instructions are not be repeated in this vignette, but the starting R object named "dgeObj" is created with exactly the same steps/data as detailed in sections 1-4.

```{r baseDGEcreation, include = F}

annotation_text <- '
# general project metadata
level=gene
source=Omicsoft
ID=BDL_Rat_LiverSlice_03Dec2017
Title=Rat Liver Slices from Bile Duct Ligation animals
Organism=Rat
GeneModel=Ensembl.R89
PlatformType=RNA-Seq
Description=Rat livers slices from sham or BDL +/- efficacious treatments incubated in vitro
Keywords=Liver slices; Bile Duct Ligation
Disease=Liver Fibrosis
Tissue=Liver
GEO=GSE120804
# additional technical data processing attributes
Technology=Illumina-HiSeq
LibraryPrep=TruSeq Stranded Total RNA
AlignmentReference=Rat.B6.0
ReadType=PE
Pipeline=RNA-Seq_BMS_v2.4.pscript
AlignmentAlgorithm=OSA
ScriptID=RNA-Seq_BMS_v2.4.pscript
# institutional attributes
BusinessUnit=Discovery
FunctionalArea=Fibrosis
Vendor=BMS
TBio_Owner=Ron Ammar
TA_Owner=John Huang
'

annotationFile <- tempfile(fileext = ".txt")
writeLines(annotation_text, con = annotationFile)

# Get the raw counts, sample annotation ("design"), and QC data from GEO
# Source: https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE120804
getLocation <- "http://ftp.ncbi.nlm.nih.gov/geo/series/GSE120nnn/GSE120804/suppl"
countsFile  <- "GSE120804_counts.txt.gz"
designFile  <- "GSE120804_geo_sample_annotation_edit.csv.gz"
qcFile      <- "GSE120804_qc_metrics.txt.gz"

temp <- tempfile()
if (download.file(glue("{getLocation}/{countsFile}"), destfile = temp, mode = 'wb') > 0) {
    stop("Counts Download Failed")
}
counts <- read.delim(temp, stringsAsFactors = FALSE, row.names = 1)

temp <- tempfile()
if (download.file(glue("{getLocation}/{designFile}"), destfile = temp, mode = 'wb')) {
    stop("Design Download Failed")
}
design <- read.csv(temp, stringsAsFactors = FALSE)

temp <- tempfile()
if (download.file(glue("{getLocation}/{qcFile}"), destfile = temp, mode = 'wb')) {
    stop("Alignment QC Download Failed")
}
alignmentQC <- read.delim(temp, stringsAsFactors = FALSE)

rownames(design) <- str_sub(design$raw.file, start = 1, end = 21)

#correct the desired case/spelling of one column
design <- design %>%
    rename(ReplicateGroup = Replicate.group)

# Create a DiseaseStatus column by parsing ReplicateGroup
design$DiseaseStatus <- rep("Sham", nrow(design))
idx <- str_detect(design$ReplicateGroup, "BDL")
design$DiseaseStatus[idx] <- "BDL"

# Create an animal# column.  The animal number is encoded in the sample.name column
design$AnimalNum <- str_match(design$Sample.name, "r[0-9]{1,3}")

# Now get the gene annotation from Ensembl/biomaRt
ens.ds      <- "rnorvegicus_gene_ensembl"
ens.mart    <- useMart(biomart = "ensembl", dataset = ens.ds)
ens.columns <- c("ensembl_gene_id", "rgd_symbol", "chromosome_name", "start_position",
                 "end_position", "strand", "gene_biotype", "description")
ens.data    <- getBM(attributes = ens.columns, 
                     values     = rownames(counts), 
                     mart       = ens.mart, 
                     useCache   = F) %>%
               distinct(ensembl_gene_id, .keep_all = T)

# Filter the list to the genes used in the test dataset and format gene info for GenomicRanges
gene.data <- left_join(data.frame(ensembl_gene_id = rownames(counts), stringsAsFactors = F),
                       ens.data,
                       by = "ensembl_gene_id") %>%
    rename(start = start_position, end = end_position) %>%
    mutate(strand = case_when(strand == -1 ~ "-",
                              strand == 1  ~ "+",
                              TRUE         ~ "*"))
rownames(gene.data) <- gene.data$ensembl_gene_id

# Get transcript level data and keep max for each gene, or alternatively, use the cds length
ens.ds          <- "rnorvegicus_gene_ensembl"
ens.mart        <- useMart(biomart = "ensembl", dataset = ens.ds)
ens.columns     <- c("ensembl_gene_id", "ensembl_transcript_id", "transcript_length")
transcript.data <- getBM(attributes = ens.columns, 
                         values     = rownames(counts), 
                         mart       = ens.mart, 
                         useCache   = F) %>%
                   arrange(desc(transcript_length)) %>%
                   distinct(ensembl_gene_id, .keep_all = T)

#Add a transcript_length column to gene.data
gene.data <- left_join(gene.data, 
                       select(transcript.data, ensembl_gene_id, ExonLength = transcript_length))
rownames(gene.data) <- gene.data$ensembl_gene_id
gene.data$ensembl_gene_id <- NULL

# enforce same order as counts
gene.data <- gene.data[rownames(counts),]

dgeObj <- DGEobj::initDGEobj(primaryAssayData  = counts,
                             rowData = gene.data,
                             colData = design,
                             level = "gene",
                             customAttr = list(Genome    = "Rat.B6.0",
                                               GeneModel = "Ensembl.R89"))

dgeObj <- annotateDGEobj(dgeObj, annotationFile)
```

Columns available in this object for building contrasts:

```{r build_cols}
designCol <- "ReplicateGroup"

str_c(designCol, (unique(dgeObj$design[[designCol]])))
```

If using formulas there may be a few additional steps that may be necessary depending on the data:

```{r projconfig}
## This step is only necessary IF there is a numeric column that you want 
## to treat as a factor in formulas
dgeObj$design$ReplicateGroup <- as.factor(dgeObj$design$ReplicateGroup)

## This step is only necessary if you want to use a ~ 1 formula.  
## The desired baseline must be made the first factor and thus the default baseline
dgeObj$design$ReplicateGroup <- relevel(dgeObj$design$ReplicateGroup, "Sham")

kable(inventory(dgeObj))
```

## Limma/Voom Workflow Reference

At this point our starting object is fully setup for the analysis.  The next step is to run the Limma/Voom Differential Gene Expression analysis as described in:

> Law CW, Alhamdoosh M, Su S et al. RNA-seq analysis is easy as 1-2-3 with 
> limma, Glimma and edgeR.  F1000Research 2018, 5:1408. [DOI: 10.12688/f1000research.9005.3](https://doi.org/10.12688/f1000research.9005.3) 


<br/><br/>

# Pre-processing

## Low Intensity Filtering

Typically, genes with near zero counts are removed before further analysis. They contain no useful information, increase the multiple test burden, and could (under some conditions) compromise the normalization and violate assumptions implicit in linear modeling.

Two methods for low intensity filtering are supplied; min counts, and FPK.  The lowIntFilter function will use any combination of these methods.  The sampleFraction argument defines the proportion of samples that must meet all specified criteria to keep a gene.  

It is typically recommended to use counts >= 10 and FPK >=5.  But the filter should be set as close as possible to criteria the original analyst used.  A custom filter can also be substituted.

Minimum counts >= 10 is commonly used to filter out low intensity genes.  But mincounts is biased against short genes.  In contrast, FPK (fragments per kilobase), described below, provides an intensity measure that is not length biased.  
  
Fragments per kilobase (FPK) is another filtering criterion.  For an average size ~2kb mRNA FPK = 5 is equivalent to counts = 10, however, FPK is not length biased.   Another useful property of FPK is that FPK can be calculated for intergenic DNA and thus provides an empirical background level of stochastic or spurious transcription.  This estimate is surely conservative in that there is very likely some real transcription going on in intergenic regions.  Typically, the intergenic FPK level is below 5 so FPK >= 5 is an appropriate threshold.

The FPK + mincount filters can both be applied together to select detected genes. The one must decide how to integrate this information across multiple samples and experiment groups. You can get more sophisticated and do this on a group-wise basis so you can include genes that were expressed in at least one of your treatment groups. That is left as an exercise for the reader -- note that groupwise filtering introduces a bias that affects your pvalue calibration.  To avoid such bias, simply require 50% of samples to pass the intensity threshold and then modify the percentage to adjust the stringency.

If using FPK, a length adjusted measure, you must also supply the geneLength argument. A Gene length value for each gene is thus required in the gene annotation if FPK is to be used.  The RSEM algorithm for generating gene counts also provide an effective length calculation for each gene that may be  conveniently used for the FPK calculations.

In this example, only the counts were provided in the GEO source and thus the gene length information required to use FPK is not available.  Therefore, a simple count threshold will be used and 50% of samples are required to meet these criteria for the gene to be included.

**Dimensions before filtering: `r dim(dgeObj)` **

```{r LowIntensityFilter}
# Gene filter criteria
countThreshold <- 10   # Must meet or exceed this value
sampleFraction <- 0.5  # Fraction of samples that must meet the criteria

dgeObj <- lowIntFilter(dgeObj, 
                       countThreshold = countThreshold,
                       sampleFraction = sampleFraction)
```

**Dimensions after filtering: `r dim(dgeObj)` **


## Filter for Protein Coding Genes  

Often an analysis is focused on protein-coding genes.  Here the Ensembl gene_biotype column is used in the gene annotation to keep only protein-coding genes.

```{r filterProteinCoding}
idx    <- dgeObj$geneData$gene_biotype == "protein_coding"
dgeObj <- dgeObj[idx,]
```

**Dimensions after filtering for protein_coding: `r dim(dgeObj)` **


<br/><br/>

# DGE Analysis  

## edgeR Normalization  

This step simply applies edgeR::calcNormFactors to effect TMM normalization. This results in a DGEList object being added to the DGEobj.  Note that the counts matrix within the DGEList object is NOT normalized counts.  Rather a separate item in the DGEList contains the norm factors and you should use the edgeR cpm function to extract normalized counts from the DGEList.

```{r Normalize}
dgeObj <- runEdgeRNorm(dgeObj, plotFile = TRUE)
```

## Define the Model Formula  

Provide a formula and construct the design matrix:

```{r ModelDefinition}
# Formula must be composed of column names from the design table
formula <- '~ 0 + ReplicateGroup'

# User-defined name for the designMatrix
designMatrixName <- "ReplicateGroupDesign"

# Build the designMatrix
design <- getItem(dgeObj, "design")
designMatrix <- model.matrix(as.formula(formula), design)

# Make sure the column names in the design matrix are legal
colnames(designMatrix) <- make.names(colnames(designMatrix))

# Capture the formula as an attribute of the design matrix
attr(designMatrix, "formula") <- formula

# Add the designMatrix to the DGEobj
dgeObj <- addItem(dgeObj, 
                  item      = designMatrix, 
                  itemName  = designMatrixName, 
                  itemType  = "designMatrix",
                  parent    = "design", 
                  overwrite = TRUE)
```

## Check for Surrogate Variables (unaccounted-for variation)

SVA looks for hidden structure in the data using PCA-like methods.  It  defines surrogate variables that can be added to your model to account  for systematic trends that do not map to known experiment factors.  This can improve power to detect changes due to factors of interest.

The ReplicateGroup design column captures both disease status and drug treatment groups.  With this design, no SVs are detected.  

```{r checkForSV}
log2cpm      <- convertCounts(dgeObj$counts, 
                              unit      = "cpm", 
                              log       = TRUE, 
                              normalize = "tmm")

designMatrix <- DGEobj::getItem(dgeObj, designMatrixName)

sva::num.sv(log2cpm, designMatrix, method = "leek")
```

To illustrate SVA use, a model is constructed using only disease status and ignoring compound treatment.  The compound treatment effects should be discoverable as a surrogate variable.  

Note that here the SVA output is captured in a fork of the main DGEobj.  

```{r runSVA}
# Formula must be composed of column names from the design table.
formula <- '~ 0 + DiseaseStatus'

# User-defined name for the designMatrix
designMatrixName <- "DiseaseStatusDesign"

# Build the designMatrix
design <- getItem(dgeObj, "design")
designMatrix <- model.matrix(as.formula(formula), design)

# Make sure the column names in the design matrix are legal
colnames(designMatrix) <- make.names(colnames(designMatrix))

# Capture the formula as an attribute of the design matrix
attr(designMatrix, "formula") <- formula

# Add the designMatrix to the DGEobj
dgeObj_SVA <- addItem(dgeObj, 
                      item      = designMatrix, 
                      itemName  = designMatrixName, 
                      itemType  = "designMatrix",
                      parent    = "design", 
                      overwrite = TRUE)

dgeObj_SVA <- runSVA(dgeObj_SVA, designMatrixName = designMatrixName)

```

Indeed SVA now identifies one surrogate variable.  

If n.sv is >0, the runSVA function adds the following changes to the DGEobj:  

1. Adds a column for each SV to the design table  
2. Stores the svobj from the SVA analysis  
3. Creates and stores a new design matrix with the SV columns and adds a "_sva" suffix to the designMatrix name   

The user can then use the new design matrix to incorporate the SVs into the analysis.   

`r kable(inventory(dgeObj_SVA))`


## Run Voom and fit the model (lmfit)  

The duplicateCorrelation method in Voom optionally allows the user to account for a random effect, such as repeated measurements on the same animal in this case.  

To invoke duplicateCorrelation in the runVoom function, assign a blocking variable to the dupCorBlock argument.  

```{r runVoom}
## Use duplicateCorrelation when subjects have been sampled more than once even
## if under different conditions (e.g. treated, untreated) 
dupCorBlock <- dgeObj$design$AnimalNum 
designMatrixName <- "ReplicateGroupDesign"

# Defaults are: qualityWeights = TRUE, runEBayes = TRUE, robust = TRUE
if (is.null(dupCorBlock)) {
  dgeObj <- runVoom(dgeObj, designMatrixName)
} else {
  dgeObj <- runVoom(dgeObj, designMatrixName, dupCorBlock = dupCorBlock)
}
```

The Mean-variance trend nicely shows the heteroscedasticity typical of RNA-Seq data (variance dependent on intensity).

If a downward hook on the left end of this distribution is observed, it means a more stringent low intensity filter should be used.  


## Run Contrasts  

Function runContrasts takes a named list of contrasts (see config chunk).  

```{r runContrasts}
# Name the design matrix to be used
designMatrixName <- "ReplicateGroupDesign"

# Print the available column names for constructing contrasts:
print(colnames(dgeObj$ReplicateGroupDesign))

# Define the named contrasts from design matrix column names
contrastList  <- list(BDL_vs_Sham    = "ReplicateGroupBDL - ReplicateGroupSham",
                      EXT1024_vs_BDL = "ReplicateGroupBDL_EXT.1024  - ReplicateGroupBDL",
                      Nint_vs_BDL    = "ReplicateGroupBDL_Nint - ReplicateGroupBDL",
                      Sora_vs_BDL    = "ReplicateGroupBDL_Sora - ReplicateGroupBDL"
)

dgeObj <- runContrasts(dgeObj, 
                       designMatrixName = designMatrixName, 
                       contrastList     = contrastList, 
                       qValue           = TRUE,
                       IHW              = TRUE)

kable(inventory(dgeObj))
```

After executing runContrasts, the topTable dataframes are present in the DGEobj and the DGE analysis is complete.  


## Alternative FDR scores  

topTable provides a BH FDR value (adj.P.Val).  Two optional FDR measures are supported that add additional columns to the topTable results. Use the Qvalue and IHW arguments to invoke these additional FDR measures.   

* `Qvalue = TRUE` adds "qvalue" and "qvalue.lfdr" columns to the topTable output.  
* `IHW = TRUE` adds columns "ihw.adj_pvalue" and "ihw.weight".  

See the vignettes for the qvalue and IHW packages for more details on these alternative FDR measures.  
